'''
89. Gray Code [Medium]

The gray code is a binary numeral system where two successive values differ in only one bit.
Given a non-negative integer n representing the total number of bits in the code, 
print the sequence of gray code. A gray code sequence must begin with 0.

Example 1:
Input: 2
Output: [0,1,3,2]
Explanation:
00 - 0
01 - 1
11 - 3
10 - 2

For a given n, a gray code sequence may not be uniquely defined.
For example, [0,2,3,1] is also a valid gray code sequence.

00 - 0
10 - 2
11 - 3
01 - 1

Example 2:
Input: 0
Output: [0]
Explanation: We define the gray code sequence to begin with 0.
             A gray code sequence of n has size = 2n, which for n = 0 the size is 20 = 1.
             Therefore, for n = 0 the gray code sequence is [0].



[Method 1]: Recursion
The output size of input n is 2**n, which is twice of the output size of graycode(n-1);
Each of the new codes in graycode(n) is 2**(n-1) greater than the codes in graycode(n-1).
Since there is only one bit's difference between every continuous two codes, like:

when n == 0:
                  0
when n == 1:
                 00
                 01
when n == 2:
                000
                001
-------------------
                011
                010
when n == 3:
               0000
               0001
               0011
               0010
-------------------
               0110
               0111
               0101
               0111
               
so we can tell, that each new code is made by adding 2**(n-1) to the old code in the reversed order.

Time: O(2**n)
Space: O(2**n)
Runtime: 40 ms, faster than 64.76% of Python3 online submissions for Gray Code.
Memory Usage: 14 MB, less than 5.26% of Python3 online submissions for Gray Code.
'''
class Solution:
    def grayCode(self, n: int) -> List[int]:
        if n == 0:
            return [0]
        prev = self.grayCode(n-1)
        ans = prev + [(code + 2**(n-1)) for code in prev[::-1]] 
        return ans
        
'''
[Method 2]: DP with the same intuition.
Time: O(2**n), in fact it takes O(n*(2**0 + 2**1 + 2**2 +...+ 2**(n-1)))
Space:O(2**n) as the size of the output list.
Runtime: 36 ms, faster than 88.09% of Python3 online submissions for Gray Code.
Memory Usage: 13.8 MB, less than 5.26% of Python3 online submissions for Gray Code.
'''
class Solution:
    def grayCode(self, n: int) -> List[int]:
        dp = [0]
        for i in range(n):
            dp += [(x + 2**i) for x in dp[::-1]]
        return dp
        
'''
[Method 3]: Bit Operation
'<<' left shift by 1 is the same as multiplying by 2, by 2 is the same as timing 2 to the power of 2, and so on;
so '1 << n' equals 2**n.
Similarly, '>>' right shift by 1 means divide by 2.
Because A^A = A, 0^0 = 0, 0^1 = 1,
Graycode can be generated by XORing the current number and its right shifted by 1 result.
E.g.
  00 ^ 00 = 00 = 0
  01 ^ 00 = 01 = 1
  10 ^ 01 = 11 = 3
  11 ^ 01 = 10 = 2
 100 ^ 10 = 110 = 6 
 ...
 
Time: O(n)
Space: O(n)

Runtime: 36 ms, faster than 88.09% of Python3 online submissions for Gray Code.
Memory Usage: 13.9 MB, less than 5.26% of Python3 online submissions for Gray Code.
'''
class Solution:
    def grayCode(self, n: int) -> List[int]:
        size = 1 << n
        res = []
        for i in range(size):
            res.append(i ^ (i >> 1))
        return res
