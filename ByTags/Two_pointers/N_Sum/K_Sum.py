'''
假设有数组nums,求其中k个数之和为target的所有可能的组合，不包含重复。
如果k为1、2、3、4时都还好，可以用2 sum, 3 sum, 4 sum的方法分别去解，
如果是用的指针的方法，则时间复杂度为O(N^(K-1))，很显然当k比较大的时候时间复杂度就很高。
我们必须要找别的的思路。

【Method 1】:回溯
其实可以把这个问题看成是求Subsets的问题，然后用回溯法做，只是多了个筛选条件（和为target）。
[Time]: 2^n, 即每个数字有选和不选两种可能。

'''
def k_sum(nums, k, target):
    if len(nums) < k: return []
    res, tmp, n = [], [], len(nums)
    nums.sort()
    if nums[-1] < target: return []
    def backtrack(res, tmp, pos):
        if len(tmp) == k:
            if sum(tmp) == target:
                res.append(tmp[:])
            return
        for i in range(pos, n):
            if i > pos and nums[i] == nums[i-1]: continue
            tmp.append(nums[i])
            backtrack(res, tmp, i+1)
            tmp.pop()
    backtrack(res, tmp, 0)
    return res

if __name__ == '__main__':
    print(k_sum([-1,3,-1,0,2,-1,0,1,0,2,3,4,-3,-4,2,1,3], 7, 0))
    print(k_sum([0,0,0,0,0,0,0,0], 5, 0))
    print(k_sum([0,0,0,0,1,2,3,5,0,0,0,0], 5, 5))

    '''
    [[-4, -3, -1, -1, 2, 3, 4], [-4, -3, -1, -1, 3, 3, 3], [-4, -3, -1, 0, 1, 3, 4], [-4, -3, -1, 0, 2, 2, 4], [-4, -3, -1, 0, 2, 3, 3], [-4, -3, -1, 1, 1, 2, 4], [-4, -3, -1, 1, 1, 3, 3], [-4, -3, -1, 1, 2, 2, 3], [-4, -3, 0, 0, 0, 3, 4], [-4, -3, 0, 0, 1, 2, 4], [-4, -3, 0, 0, 1, 3, 3], [-4, -3, 0, 0, 2, 2, 3], [-4, -3, 0, 1, 1, 2, 3], [-4, -3, 0, 1, 2, 2, 2], [-4, -1, -1, -1, 0, 3, 4], [-4, -1, -1, -1, 1, 2, 4], [-4, -1, -1, -1, 1, 3, 3], [-4, -1, -1, -1, 2, 2, 3], [-4, -1, -1, 0, 0, 2, 4], [-4, -1, -1, 0, 0, 3, 3], [-4, -1, -1, 0, 1, 1, 4], [-4, -1, -1, 0, 1, 2, 3], [-4, -1, -1, 0, 2, 2, 2], [-4, -1, -1, 1, 1, 2, 2], [-4, -1, 0, 0, 0, 1, 4], [-4, -1, 0, 0, 0, 2, 3], [-4, -1, 0, 0, 1, 1, 3], [-4, -1, 0, 0, 1, 2, 2], [-4, 0, 0, 0, 1, 1, 2], [-3, -1, -1, -1, 0, 2, 4], [-3, -1, -1, -1, 0, 3, 3], [-3, -1, -1, -1, 1, 1, 4], [-3, -1, -1, -1, 1, 2, 3], [-3, -1, -1, -1, 2, 2, 2], [-3, -1, -1, 0, 0, 1, 4], [-3, -1, -1, 0, 0, 2, 3], [-3, -1, -1, 0, 1, 1, 3], [-3, -1, -1, 0, 1, 2, 2], [-3, -1, 0, 0, 0, 1, 3], [-3, -1, 0, 0, 0, 2, 2], [-3, -1, 0, 0, 1, 1, 2], [-1, -1, -1, 0, 0, 0, 3], [-1, -1, -1, 0, 0, 1, 2], [-1, -1, 0, 0, 0, 1, 1]]
    '''



# 【Method 2】:
# 如果n-k比较小的话，可以考虑反向求和为sum(nums) - target的n-k个数的可能组合。
